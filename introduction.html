<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Electron Diffraction - Signal Class &#8212; pyXem 0.5 documentation</title>
    <link rel="stylesheet" href="_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/custom.css" type="text/css" />
    <script type="text/javascript" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="_static/bootstrap-3.3.7/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="_static/bootstrap-sphinx.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Post-facto Imaging" href="post_facto_imaging.html" />
    <link rel="prev" title="pyXem - Pythonic Crystallographic Electron Microscopy" href="index.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="index.html">
          pyXem</a>
        <span class="navbar-text navbar-version pull-left"><b>0.5</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Electron Diffraction - Signal Class</a></li>
<li class="toctree-l1"><a class="reference internal" href="post_facto_imaging.html">Post-facto Imaging</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributor Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="bibliography.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="modules.html">pyxem</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">Electron Diffraction - Signal Class</a><ul>
<li><a class="reference internal" href="#alignment-corrections-calibration">Alignment, Corrections &amp; Calibration</a></li>
<li><a class="reference internal" href="#radial-integration">Radial Integration</a></li>
<li><a class="reference internal" href="#background-removal">Background Removal</a><ul>
<li><a class="reference internal" href="#background-modelling">Background Modelling</a></li>
<li><a class="reference internal" href="#morphological-background-removal">Morphological Background Removal</a></li>
</ul>
</li>
<li><a class="reference internal" href="#peak-finding">Peak Finding</a><ul>
<li><a class="reference internal" href="#zaeferrer-peak-finder">Zaeferrer peak finder</a></li>
<li><a class="reference internal" href="#ball-statistical-peak-finder">Ball statistical peak finder</a></li>
<li><a class="reference internal" href="#matrix-based-peak-finding">Matrix based peak finding</a></li>
<li><a class="reference internal" href="#interactive-parametrization">Interactive Parametrization</a></li>
</ul>
</li>
<li><a class="reference internal" href="#unsupervised-machine-learning">Unsupervised Machine Learning</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
  <li>
    <a href="index.html" title="Previous Chapter: pyXem - Pythonic Crystallographic Electron Microscopy"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; pyXem - Pytho...</span>
    </a>
  </li>
  <li>
    <a href="post_facto_imaging.html" title="Next Chapter: Post-facto Imaging"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm hidden-tablet">Post-facto Imaging &raquo;</span>
    </a>
  </li>
              
            
            
            
            
              <li class="hidden-sm">
<div id="sourcelink">
  <a href="_sources/introduction.rst.txt"
     rel="nofollow">Source</a>
</div></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content">
      
  <div class="section" id="electron-diffraction-signal-class">
<h1>Electron Diffraction - Signal Class<a class="headerlink" href="#electron-diffraction-signal-class" title="Permalink to this headline">¶</a></h1>
<p>pyXem provides a library of tools primarily developed for the analysis of
4D-S(P)ED data, although many methods are applicable to electron diffraction
data in general. 4D-S(P)ED datasets comprise many thousands of electron
diffraction patterns and the <a class="reference internal" href="pyxem.signals.html#pyxem.signals.electron_diffraction.ElectronDiffraction" title="pyxem.signals.electron_diffraction.ElectronDiffraction"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElectronDiffraction</span></code></a> class provides a
specialized HyperSpy Signal() class for this data. If the data array is imagined
as a tensor, D, of rank n then entries are addressed by n indices, D_{i,j,…,n}.
The HyperSpy Signal() class allows some indices, or equivalently some axes, to
be defined as navigation axes and others to be defined as signal axes. In the
context of a 4D-S(P)ED data, the two axes corresponding to the real-space scan
dimensions (i, j) are set as navigation axes and the two axes corresponding to
the diffraction pattern plane (a, b) are set as signal axes, which can be
written:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">|</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>There are numerous ways to obtain physical insight from 4D-S(P)ED data all of
which ultimately require the assignment of an atomic arrangement to each probe
position that explains the observed diffraction. Different approaches to achieve
this goal are summarized in the following schematic.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/sed_analysis_scheme.png"><img alt="_images/sed_analysis_scheme.png" src="_images/sed_analysis_scheme.png" style="width: 600px;" /></a>
</div>
<p>To illustrate the data methods implemented in pyXem we will consider data from a
model system of GaAs nanowires comprising a series of twinned regions along its
length, as shown below. (We acknowledge Prof. Ton van Helvoort, NTNU, Norway, for
providing these samples).</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/model_system.png"><img alt="_images/model_system.png" src="_images/model_system.png" style="width: 600px;" /></a>
</div>
<p>The methods described in this documentation are demonstrated in a series of
[Jupyter Notebooks](<a class="reference external" href="http://jupyter.org/">http://jupyter.org/</a>), which can be used as analysis
templates on which to build. These are available <a class="reference external" href="https://github.com/pyxem/pyxem-demos">here</a>.</p>
<p>Experimental parameters associated with the data acquisition can be stored in
metadata for future reference using the utility function
<a class="reference internal" href="pyxem.signals.html#pyxem.signals.electron_diffraction.ElectronDiffraction.set_experimental_parameters" title="pyxem.signals.electron_diffraction.ElectronDiffraction.set_experimental_parameters"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_experimental_parameters()</span></code></a>, for example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dp</span><span class="o">.</span><span class="n">set_experimental_parameters</span><span class="p">(</span><span class="n">accelerating_voltage</span><span class="o">=</span><span class="mf">300.</span><span class="p">,</span>
<span class="go">                                   camera_length=21.,</span>
<span class="go">                                   scan_rotation=277.,</span>
<span class="go">                                   convergence_angle=0.7,</span>
<span class="go">                                   exposure_time=10.)</span>
</pre></div>
</div>
<div class="section" id="alignment-corrections-calibration">
<h2>Alignment, Corrections &amp; Calibration<a class="headerlink" href="#alignment-corrections-calibration" title="Permalink to this headline">¶</a></h2>
<p>Experimental artifacts in 4D-S(P)ED commonly include: (1) geometric distortions
due to projection optics, (2) small translations of the direct beam in the
diffraction plane, and (3) recorded intensities that depend on the response of
the detector. Methods to correct these effects to a first order approximation
are made available in pyXem.</p>
<p>Projection distortions may be (approximately) corrected by the application of an
opposite image distortion, often an affine transformation, to all recorded
diffraction patterns. The appropriate transformation may be determined using
diffraction patterns acquired from a reference sample and then applied using
<a class="reference internal" href="pyxem.signals.html#pyxem.signals.electron_diffraction.ElectronDiffraction.apply_affine_transformation" title="pyxem.signals.electron_diffraction.ElectronDiffraction.apply_affine_transformation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">apply_affine_transformation()</span></code></a>. E.g.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dp</span><span class="o">.</span><span class="n">apply_affine_transformation</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.99</span><span class="p">,</span><span class="mi">0</span>   <span class="p">,</span><span class="mi">0</span><span class="p">],</span>
<span class="go">                                             [0   ,0.69,0],</span>
<span class="go">                                             [0   ,0   ,1]]))</span>
</pre></div>
</div>
<p>Translation of the direct beam is corrected for by aligning the stack of
diffraction patterns. This can be achieve with</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dp</span><span class="o">.</span><span class="n">center_direct_beam</span><span class="p">()</span>
</pre></div>
</div>
<p>This method has an argument (sigma) that should be smaller (in pixel terms) than the distance from the edge of
the nearest diffraction spot to the direct beam. Furthermore, the code assumes the direct beam is brightest spot.</p>
<p>Intensity corrections most simply involve gain normalization based on
dark-reference and bright-reference images. Such gain normalization may be
performed in pyXem using <a class="reference internal" href="pyxem.signals.html#pyxem.signals.electron_diffraction.ElectronDiffraction.apply_gain_normalisation" title="pyxem.signals.electron_diffraction.ElectronDiffraction.apply_gain_normalisation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">apply_gain_normalisation()</span></code></a>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dp</span><span class="o">.</span><span class="n">apply_gain_normalisation</span><span class="p">(</span><span class="n">bref</span><span class="o">=</span><span class="n">bright_reference</span><span class="p">,</span> <span class="n">dref</span><span class="o">=</span><span class="n">dark_reference</span><span class="p">)</span>
</pre></div>
</div>
<p>Following alignment and the application of necessary corrections to the data (ESSENTIAL DO NOT SKIP!), one
may be calibrate the signals. Utility functions exist to apply calibrations to the diffraction and scan axes respectively.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dp</span><span class="o">.</span><span class="n">set_diffraction_calibration</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dp</span><span class="o">.</span><span class="n">set_scan_calibration</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The diffraction axes should be calibrated in A^{-1}/px and the scan
axes should be calibrated in nm/px.</p>
</div>
</div>
<div class="section" id="radial-integration">
<h2>Radial Integration<a class="headerlink" href="#radial-integration" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="pyxem.signals.html#pyxem.signals.electron_diffraction.ElectronDiffraction.get_radial_profile" title="pyxem.signals.electron_diffraction.ElectronDiffraction.get_radial_profile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_radial_profile()</span></code></a> method integrates every
two-dimensional electron diffraction pattern about its and is applied as:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dp</span><span class="o">.</span><span class="n">get_radial_profile</span><span class="p">()</span>
</pre></div>
</div>
<p>The result is a one-dimensional plot of diffracted intensity as a function of
scattering angle.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="images/radial_profile.png"><img alt="images/radial_profile.png" src="images/radial_profile.png" style="width: 400px;" /></a>
</div>
<p>Again, this will not work if you fail to center all of the patterns in your S(P)ED scan.</p>
</div>
<div class="section" id="background-removal">
<h2>Background Removal<a class="headerlink" href="#background-removal" title="Permalink to this headline">¶</a></h2>
<p>Background subtraction is important for extracting accurate diffracted
intensities and achieving reliable pattern matching or peak finding. The aims in
these two cases are significantly different. Background subtraction may be
achieved in pyXem via the <a class="reference internal" href="pyxem.signals.html#pyxem.signals.electron_diffraction.ElectronDiffraction.remove_background" title="pyxem.signals.electron_diffraction.ElectronDiffraction.remove_background"><code class="xref py py-meth docutils literal notranslate"><span class="pre">remove_background()</span></code></a>
method, which has multiple options.</p>
<div class="section" id="background-modelling">
<h3>Background Modelling<a class="headerlink" href="#background-modelling" title="Permalink to this headline">¶</a></h3>
<p>The background may be modelled by fitting a model to the radial profile of the
diffraction data. The model may then be made ciruclarly symmetric and subtracted.
Numerous models could in principle be used and one option that has been useful
for data acquired on fluorescent screens, but is difficult to justify physically,
contains a Lorentzian to model the direct beam, an exponential function to
model the tail of diffuse scattering, and a first order polynomial to model
slower decay at higher scattering angles. This is applied as:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dp</span><span class="o">.</span><span class="n">remove_background</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;model&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Backgound modelling, as described above yields the following:</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/background_model.png"><img alt="_images/background_model.png" src="_images/background_model.png" style="width: 600px;" /></a>
</div>
</div>
<div class="section" id="morphological-background-removal">
<h3>Morphological Background Removal<a class="headerlink" href="#morphological-background-removal" title="Permalink to this headline">¶</a></h3>
<p>Background removal based on morphological operations provides a fast and
versatile method for removing non-smooth background. A so-called h-dome method
is implemented here. This involves forming a ‘seed’ image by subtracting a
constant offset, h, from the raw image. A morphological reconstruction by
dilatation is then performed in which high-intensity values replace nearby low
intensity values. The seed image specifies the values that are subject to
dilatation and the raw image specifies the maximum value at each pixel. The
reconstructed image then appears similar to the original image but with peak
above the h value cut off.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dp</span><span class="o">.</span><span class="n">remove_background</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;h-dome&#39;</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="mf">0.4</span><span class="p">)</span>
</pre></div>
</div>
<p>Morphological background removal, as described above yields the following:</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/background_morphological.png"><img alt="_images/background_morphological.png" src="_images/background_morphological.png" style="width: 600px;" /></a>
</div>
</div>
</div>
<div class="section" id="peak-finding">
<h2>Peak Finding<a class="headerlink" href="#peak-finding" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="pyxem.signals.html#pyxem.signals.electron_diffraction.ElectronDiffraction.find_peaks" title="pyxem.signals.electron_diffraction.ElectronDiffraction.find_peaks"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_peaks()</span></code></a> method provides access to a
number of algorithms for that achieve peak finding in electron diffraction
patterns. The found peak positions are returned as
The methods available are as follows:</p>
<div class="section" id="zaeferrer-peak-finder">
<h3>Zaeferrer peak finder<a class="headerlink" href="#zaeferrer-peak-finder" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dp</span><span class="o">.</span><span class="n">find_peaks</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;zaefferer&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>This algorithm was developed by Zaefferer and the implementation here is after
the description of the algorithm in the Ph.D. thesis of Thomas A. White. It is
based on a gradient threshold followed by a local maximum search within a square
window, which is moved until it is centered on the brightest point, which is
taken as a peak if it is within a certain distance of the starting point.</p>
</div>
<div class="section" id="ball-statistical-peak-finder">
<h3>Ball statistical peak finder<a class="headerlink" href="#ball-statistical-peak-finder" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dp</span><span class="o">.</span><span class="n">find_peaks</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;stat&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Developed by Gordon Ball, and described in the Ph.D. thesis of Thomas A.
White, this method is based on finding points which have a statistically
higher value than the surrounding areas, then iterating between smoothing and
binarising until the number of peaks has converged. This method is slow, but
very robust to a variety of image types.</p>
</div>
<div class="section" id="matrix-based-peak-finding">
<h3>Matrix based peak finding<a class="headerlink" href="#matrix-based-peak-finding" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dp</span><span class="o">.</span><span class="n">find_peaks</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;laplacian_of_gaussians&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dp</span><span class="o">.</span><span class="n">find_peaks</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;difference_of_gaussians&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>These methods are essentially wrappers around the
<a class="reference external" href="http://scikit-image.org/docs/dev/auto_examples/plot_blob.html">scikit-image</a> Laplacian
of Gaussian and Difference of Gaussian methods, based on stacking the
Laplacian/difference of images convolved with Gaussian kernels of various
standard deviations. Both are very rapid and relatively robust, given
appropriate parameters.</p>
</div>
<div class="section" id="interactive-parametrization">
<h3>Interactive Parametrization<a class="headerlink" href="#interactive-parametrization" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dp</span><span class="o">.</span><span class="n">find_peaks_interactive</span><span class="p">()</span>
</pre></div>
</div>
<p>Many of the peak finding algorithms implemented here have a number of tuneable
parameters that significantly affect their accuracy and speed. Finding the
correct parameters can be difficult. An interactive tool for the Jupyter
notebook has been developed to help.</p>
<p>Several widgets are available:</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/interactive_peaks.png"><img alt="_images/interactive_peaks.png" src="_images/interactive_peaks.png" style="width: 600px;" /></a>
</div>
<ul class="simple">
<li>The method selector is used to compare different methods. The last-set
parameters are maintained.</li>
<li>The signal navigator is used where a signal has navigation axes. The
randomizer will select random indices.</li>
<li>The parameter adjusters will update the parameters of the method and re-plot
the new peaks.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Some methods take significantly longer than others, particularly
where there are a large number of peaks to be found. The plotting window
may be inactive during this time.</p>
</div>
</div>
</div>
<div class="section" id="unsupervised-machine-learning">
<h2>Unsupervised Machine Learning<a class="headerlink" href="#unsupervised-machine-learning" title="Permalink to this headline">¶</a></h2>
<p>Unsupervised machine learning algorithms may be applied to SED as a route to
obtain representative “component diffraction patterns” and their respective
“loadings” in real space. These methods involve unfolding each diffraction
pattern into an image vector and stacking these vectors together to construct a
data matrix, which is then factorized:</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/ml_sed_scheme.png"><img alt="_images/ml_sed_scheme.png" src="_images/ml_sed_scheme.png" style="width: 600px;" /></a>
</div>
<p>Various matrix decomposition methods are available through the decomposition()
method, which is inherited directy from HyperSpy and is documented
<a class="reference external" href="http://hyperspy.org/hyperspy-doc/current/user_guide/mva.html">here</a>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dp</span><span class="o">.</span><span class="n">decomposition</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright Copyright 2017-2018, Python Crystallographic Electron Microscopy.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.4.<br/>
    </p>
  </div>
</footer>
  </body>
</html>